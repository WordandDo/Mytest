基于您提供的代码库，特别是 system_tools.py、rag_server.py、search_tools.py 和 main.py，我为您总结了两套标准的开发模板。
系统的核心设计理念是**“注册表 + 自动发现”，这意味着大多数情况下不需要修改 main.py 的代码**，而是通过命名约定和配置文件来驱动。

---
模板一：资源支持型开发模板 (Resource-Backed Pattern)
适用场景：需要独占资源（如虚拟机、数据库连接、浏览器实例）、需要状态保持（Session）、需要生命周期管理（申请/初始化/释放）的工具。
1. 严格的命名约定
- 文件名：必须命名为 src/mcp_server/{resource_type}_server.py。
  - 原因：system_tools.py 中的 setup_batch_resources 函数会根据配置中的资源类型字符串（如 rag），动态拼接并 import mcp_server.rag_server。
- 初始化函数名：必须命名为 {resource_type}_initialization。
  - 原因：系统会通过反射机制查找并调用此函数来完成资源的“后置配置”（如加载特定任务数据）。
2. 代码结构模板
在 src/mcp_server/{resource_type}_server.py 中：
Python
import os
import json
from typing import Dict, Any
from mcp_server.core.registry import ToolRegistry

# 1. 全局会话存储 (必需)# 用于在不同工具调用之间保持状态 (WorkerID -> Resource/Client)# system_tools.py 会通过反射写入这里，所以变量名建议固定或在 system_tools 中注册映射
MY_RESOURCE_SESSIONS: Dict[str, Dict[str, Any]] = {}

# 2. 动态初始化入口 (必需)# 由 system_tools.py 自动调用async def {resource_type}_initialization(worker_id: str, config_content: Any = None) -> bool:"""
    当资源被分配后，系统会自动调用此函数进行初始化配置
    """
    session = MY_RESOURCE_SESSIONS.get(worker_id)
    if not session:
        return False# 在这里处理 config_content (例如加载特定知识库、下载特定文件)# 并更新 session 状态return True# 3. 生命周期工具 (推荐隐藏)# 即使有自动分配，保留手动 setup/teardown 也是为了调试和兼容@ToolRegistry.register_tool("my_resource_lifecycle", hidden=True)async def setup_my_resource_session(worker_id: str, ...) -> str:# 手动申请资源的逻辑 (通常调用 RESOURCE_API_URL)pass@ToolRegistry.register_tool("my_resource_lifecycle", hidden=True)async def teardown_my_resource_session(worker_id: str) -> str:# 清理 session 和释放资源
    MY_RESOURCE_SESSIONS.pop(worker_id, None)
    return "Released"# 4. 业务功能工具 (核心)@ToolRegistry.register_tool("my_resource_actions")async def perform_action(worker_id: str, query: str) -> str:
    session = MY_RESOURCE_SESSIONS.get(worker_id)
    if not session:
        return "Error: No active session"# 使用 session 中的 client/token 进行操作return "Action Result"
3. 关联修改 (System Tools)
如果你的资源类型是全新的（不仅仅是新代码，而是新类型的资源），你可能需要微调 src/mcp_server/system_tools.py 中的 _sync_resource_sessions 和 _cleanup_resource_sessions 函数，把你的 MY_RESOURCE_SESSIONS 加入到同步列表里，以便 Gateway 能把申请到的 IP/Token 注入进去。

---
模板二：无资源分配器开发模板 (Standalone/Stateless Pattern)
适用场景：纯计算、搜索、数据处理、或者自带认证（不需要从 Resource API 申请）的工具。
1. 宽松的命名约定
- 文件名：任意 .py 文件，只要位于 src/mcp_server/ 目录下即可。例如 src/mcp_server/math_tools.py。
- 原因：main.py 启动时会执行 ToolRegistry.autodiscover("mcp_server")，它会扫描该目录下所有文件并触发装饰器注册。
2. 代码结构模板
在 src/mcp_server/my_tools.py 中：
Python
import os
from mcp_server.core.registry import ToolRegistry

# 1. 自身认证逻辑 (如果需要)# 直接从环境变量读取，不依赖 Resource API 分配
API_KEY = os.environ.get("MY_TOOL_API_KEY")

# 2. 定义工具@ToolRegistry.register_tool("my_utility_group")def calculate_something(param1: str, param2: int) -> dict:"""
    这里写工具描述，LLM 会看到。
    """if not API_KEY:
        return {"error": "API key not configured"}
        
    # 执行无状态逻辑
    result = perform_logic(param1, param2)
    return {"status": "success", "data": result}

---
关键整合：如何在 Main 函数与配置中生效
无论是哪种模板，都不需要修改 src/mcp_server/main.py 的代码逻辑。main.py 已经编写得足够通用。
你需要修改的是 gateway_config.json（配置文件），这才是控制工具是否启用的开关。
配置文件修改示例
在 gateway_config.json 的 modules 列表中添加你的配置：
JSON
{
  "server_name": "Unified Gateway",
  "modules": [
    {
      // 对应模板一 (资源型)"resource_type": "my_new_resource", // 必须与文件名 {type}_server.py 匹配
      "tool_groups": [
        "my_resource_lifecycle",
        "my_resource_actions"
      ]
    },
    {
      // 对应模板二 (无资源型)"resource_type": "utility", // 这里的名字不影响逻辑，仅作标记
      "tool_groups": [
        "my_utility_group" // 必须与代码中 @register_tool("...") 匹配
      ]
    }
  ]
}
总结与对比
暂时无法在飞书文档外展示此内容
特别注意：
如果你的工具涉及到第三方 API (如 Google Search)，请确保在 src/utils/ 下有对应的服务实现（如 src/utils/search_v2/），并在工具文件中做好 try-import 处理，防止因缺少依赖导致整个 Server 启动失败。
